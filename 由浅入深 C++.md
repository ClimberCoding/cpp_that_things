# 由浅入深 C++

## Q0：如何高效学习C++

> 这里引用 @皮皮关 的文章回答：https://www.zhihu.com/question/30196513/answer/463544930
> 下面贴上原文：

### 一、学习原则

**第一，学习的基本原则：啃书的同时一定要写代码。**

一边看书一边敲代码是高效学习C++最关键、最基础的方法。所有看懂了的、看不懂的知识点，都要保证出现在你的编辑器里，并且运行过。

**第二，C++是最重要的语言之一，坚信这一点。**

C++的应用范围非常广泛，比如操作系统、大型软件、大型基础服务、网游服务器、3D游戏引擎、科研领域等等，仅仅是在一些热门领域比如网站后台中不太常见。

而且，许多高级语言本身（或者说虚拟机本身）就是用C或C++实现的，不限于Python、Lua、Java等等，没有C/C++就没有一切。

搞明白这一点会增强学习C++的动力。

### 二、学习方法

**1、虽然C++的上限非常高，但是分阶段性逐步学习是没有问题的。**

按照流行的说法，C++集成了多种编程范式，包括 过程式编程、面向对象、泛型、函数式等等（我总感觉实际不止4种）。

而且，根据软件的原理来说，只需要一种编程范式（比如过程式），就已经可以解决所有问题了，从数学上来讲这么多的范式并不是必要的。实际上，只要你掌握了基础的过程式编程，再加一半面向对象的技术，就已经可以解决相当多问题了。

比如很早以前MFC还流行的时候，大部分人用的C++也只不过就是OO那些东西而已，照样做出了丰富多彩的应用程序。

**2、如何分阶段学习**

进行长期的C++学习，很像是攀岩，虽然看似学习曲线陡峭，但是每一步都是有根有据的，并不会一下子飞起来。

学过C的人喜欢从C with class的角度开始看C++，深表赞同，咱们就从这里开始。

1、学习C++并不需要从C开始，但是指针、函数等等基本的使用务必做到100%熟悉。这也是学习C语言最强调的一点。C++对类型的限定更为严格，相对C来说反而不会很“跳脱”，可能反而好学一些。

2、之后就是class相关的一部分，广泛来说就是OO那一套东西。基本的有类、对象，到最后不过也就是多态而已。这一部分还是没什么太难的东西，多思考、多实践即可。

3、再往后遇到模版、泛型。虽然泛型编程这部分上限很高，但是下限也很低。你只要能正确地利用泛型扩展class的功能、提高易用性，就算是懂了一半；而且这一半一点也不难，照猫画虎即可学会。

4、到这里同时还会遇到STL和常用容器，往浅说，你只要知道什么时候用什么容器、怎样用好容器；往深说，你要尽可能多了解多种容器的实现原理、内存布局和规则等等。一步一步深入理解。

5、这时候你就已经来到一个“初级C++程序员”的台阶上了，再往后最好不要闭门造车，还是要兼顾学习和项目实践，才能更稳定地进一步发展，避免走歪。

 ![img](https://climber-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202204081053081.png)

**3、可能遇到的麻烦**

只要一步一步来，一年左右时间应该能基本达到上面所说的水准，但在这个过程中可能遇到一些比较大的坎，比如：

1. 知道“宏”怎么用，但是复杂的看不懂。
2. 知道面向对象怎么写，但是不能合理设计、使用OO
3. 指针、引用、对象、const、运算符重载都懂，但是放在一起就乱了。
4. 写出来的程序内存管理比较乱，有崩溃或者泄露不知道怎么改。

等等。

### 三、总结

和其它流行语言横向比较的话，C++不是一门简单的语言，但是物有所值。

在学习过程中，任何问题都是会发生的，要解决这些问题只要记住一点——**不要在意学习快慢，在细节上花10倍时间是值得的，只要每个地方都花时间搞懂，那就离大牛不远了。**

**你在知乎上看到的很多C++大牛，都是在这方面有意无意地花费了海量的时间，自然就成为高手了。**

> **这里再引用一句 @觅新笑话中 的话**
> **用C++最大的乐趣就是造轮子，提高C++编程水平最好的方法也是造轮子。知其然并知其所以然，才能完成编程能力的蜕变。**

## Q：聊聊 “引用” 和 “指针” 那些事

> **缘起：**
> 在刷LC：[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) 的时候，当 `vector<int>` 不加 `&` 时，会提示报错 “超出时间限制” ，为什么会出现这种状况呢？探究其原因。











> **拓展：**
> `引用` 和 `指针` 的区别？





## Q：“const” 关键字





## Q：“void*” 为何物

> 资料参考：
> 1、《TC++PL》：P128、P149
> 2、cppreference：https://zh.cppreference.com/w/cpp/language/types#void_.E7.B1.BB.E5.9E.8B

### why：为什么会有 void*

在某些偏向底层的代码中，我们偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址来存储或传递对象。它们的作用大多是操作硬件资源。

例如：

```cpp
void* my_alloc(size_t n);	// 从特定的堆上分配n个字节的内存空间
```

### what：void* 是什么

void* 的含义是 “指向未知类型对象的指针”。

一个 void* 可以被赋给另一个 void* ，两个 void* 还能比较是否相等，并且我们可以把 void* 显式转换为其他类型。

### How：怎么用 void*

因为编译器并不清楚 void* 所指的对象到底是什么类型，所以对它执行其他操作并不安全，并且会引发编译错误。

所以，**要使用 void* ，我们必须把它显式转换成某一特定类型的指针。**

例如：

```cpp
void func(int* p) {
    void* p1 = p;	// ok: 发生了从 int* 到 void* 的隐式转换
    *p1 = 1;	// error: 不允许解引用 void*
    ++p1;		// error: 不允许对 void* 执行递增操作（不清楚void* 所指向对象的尺寸）
    
    int* p2 = static_cast<int*>(p1);	// 显示转换回 int*
    
    double* d_p1 = p1;	// error: 要显示转换
    double* d_p2 = p;		// error
    double* d_p3 = static_cast<double*>(p1);	// 不安全
}
```

解释一下 `double* d_p3 = static_cast<double*>(p1);` 为什么不安全？

一般情况下，如果某个指针已经被 强制类型转换 成一种与实际所指对象类型完全不同的新类型，则使用转换后的指针是不安全的行为。

如上面的例子，实际上 p1 所指的是 int 类型的一段内存，假设系统分配的内存占4个字节，而转换后的 double 类型占8个字节，那么操作之后将会造成意想不到的后果。

> warning：**函数指针和指向类成员的指针不能被赋给 void* 。** 

### where：void* 主要的用途

1. 当我们无法假定对象的类型时，向函数传递指向该对象的指针；
2. 从函数返回未知类型的对象。（要使用这样的对象，必须先显示类型转换）

> 在系统上层代码中很少用到 void* ，一旦出现，你就要认真核实是不是存在设计上的错误。

例如：

```cpp
void* p;	// 指针所指的对象类型未知
// （PS：待补充）
```



### 加餐：浅谈 “void”

从语法结构上来讲，void 属于基本类型，但它又是无法变为完整的 **不完整类型** （从而不允许存在 void 类型的对象）

例如：

```cpp
void x;		// error: 不存在 void 类型的对象
void& r;	// error: 不存在到 void 的引用
void func();	// 函数 func 不返回任何实际的值
void* p;	// 指针所指的对象类型未知
```

当我们声明一个函数时，必须指明其返回类型。从逻辑上讲，如果某个函数不返回任何值，也许我们会希望直接忽略返回值部分。但这种想法会违反C++的语法规则。因此，我们使用 void 表示函数的返回值为空，此时 void 可以看成一种 “伪返回类型”。

这样，我们就引出了 void 的用途：

1. 作为函数的返回类型用于说明函数不返回任何实际的值；
2. 作为指针的基本类型部分，以表明指针所指对象的类型未知。



## Q：函数指针 和 指针函数，到底如何区分？





## Q：区分强制类型转换 “static_cast、dynamic_cast、const_cast 和 reinterpret_cast”





## Q：聊聊 “左值” 和 “右值”

