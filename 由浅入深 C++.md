# 由浅入深 C++

## 前言：如何高效学习C++

> 这里引用 @皮皮关 的文章回答：https://www.zhihu.com/question/30196513/answer/463544930
> 下面贴上原文：

### 一、学习原则

**第一，学习的基本原则：啃书的同时一定要写代码。**

一边看书一边敲代码是高效学习C++最关键、最基础的方法。所有看懂了的、看不懂的知识点，都要保证出现在你的编辑器里，并且运行过。

**第二，C++是最重要的语言之一，坚信这一点。**

C++的应用范围非常广泛，比如操作系统、大型软件、大型基础服务、网游服务器、3D游戏引擎、科研领域等等，仅仅是在一些热门领域比如网站后台中不太常见。

而且，许多高级语言本身（或者说虚拟机本身）就是用C或C++实现的，不限于Python、Lua、Java等等，没有C/C++就没有一切。

搞明白这一点会增强学习C++的动力。

### 二、学习方法

**1、虽然C++的上限非常高，但是分阶段性逐步学习是没有问题的。**

按照流行的说法，C++集成了多种编程范式，包括 过程式编程、面向对象、泛型、函数式等等（我总感觉实际不止4种）。

而且，根据软件的原理来说，只需要一种编程范式（比如过程式），就已经可以解决所有问题了，从数学上来讲这么多的范式并不是必要的。实际上，只要你掌握了基础的过程式编程，再加一半面向对象的技术，就已经可以解决相当多问题了。

比如很早以前MFC还流行的时候，大部分人用的C++也只不过就是OO那些东西而已，照样做出了丰富多彩的应用程序。

**2、如何分阶段学习**

进行长期的C++学习，很像是攀岩，虽然看似学习曲线陡峭，但是每一步都是有根有据的，并不会一下子飞起来。

学过C的人喜欢从C with class的角度开始看C++，深表赞同，咱们就从这里开始。

1、学习C++并不需要从C开始，但是指针、函数等等基本的使用务必做到100%熟悉。这也是学习C语言最强调的一点。C++对类型的限定更为严格，相对C来说反而不会很“跳脱”，可能反而好学一些。

2、之后就是class相关的一部分，广泛来说就是OO那一套东西。基本的有类、对象，到最后不过也就是多态而已。这一部分还是没什么太难的东西，多思考、多实践即可。

3、再往后遇到模版、泛型。虽然泛型编程这部分上限很高，但是下限也很低。你只要能正确地利用泛型扩展class的功能、提高易用性，就算是懂了一半；而且这一半一点也不难，照猫画虎即可学会。

4、到这里同时还会遇到STL和常用容器，往浅说，你只要知道什么时候用什么容器、怎样用好容器；往深说，你要尽可能多了解多种容器的实现原理、内存布局和规则等等。一步一步深入理解。

5、这时候你就已经来到一个“初级C++程序员”的台阶上了，再往后最好不要闭门造车，还是要兼顾学习和项目实践，才能更稳定地进一步发展，避免走歪。

 ![img](https://climber-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202204081053081.png)

**3、可能遇到的麻烦**

只要一步一步来，一年左右时间应该能基本达到上面所说的水准，但在这个过程中可能遇到一些比较大的坎，比如：

1. 知道“宏”怎么用，但是复杂的看不懂。
2. 知道面向对象怎么写，但是不能合理设计、使用OO
3. 指针、引用、对象、const、运算符重载都懂，但是放在一起就乱了。
4. 写出来的程序内存管理比较乱，有崩溃或者泄露不知道怎么改。

等等。

### 三、总结

和其它流行语言横向比较的话，C++不是一门简单的语言，但是物有所值。

在学习过程中，任何问题都是会发生的，要解决这些问题只要记住一点——**不要在意学习快慢，在细节上花10倍时间是值得的，只要每个地方都花时间搞懂，那就离大牛不远了。**

**你在知乎上看到的很多C++大牛，都是在这方面有意无意地花费了海量的时间，自然就成为高手了。**

> **这里再引用一句 @觅新笑话中 的话**
> **用C++最大的乐趣就是造轮子，提高C++编程水平最好的方法也是造轮子。知其然并知其所以然，才能完成编程能力的蜕变。**



## 一、基础知识

### Q：聊聊 “引用” 和 “指针” 那些事

> **缘起：** 在刷LC：[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) 的时候，当 `vector<int>` 不加 `&` 时，会提示报错 “超出时间限制” ，为什么会出现这种状况呢？探究其原因。

在C++中，我们通常可以用对象的名字来对它进行直接操作。但，有些对象有着高贵的 “身份” ，我们不能直接通过称呼它的名字来进行一系列操作。

这样我们就需要通过其他的方式来访问它们。而对象位于内存的某个地址中，如果我们知道对象的地址和类型，那不就可以间接访问它了。在C++中存放及使用内存地址通过 指针 和 引用 完成的。

#### 初识指针

这里使用 int 类型来阐述：

对于 int 类型来说，`int*`表示 “指向 int 类型的指针” 。换句话说，`int*` 类型的变量可以存放 int 类型对象的地址。

例如：

```cpp
int a = 12;
int* p = &a;	// p中存放着a的地址，&是取地址符
```

用图形化来表示：

![image-20220408162702495](https://climber-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202204081627535.png)

指针有一个基本操作：**解引用**，即引用指针所指的对象。解引用运算符是一个前置一元运算符，对应的符合是 `*` 。

例如：

```cpp
// 接上面例子
*p = 155;
std::cout << a << std::endl;	// 输出 155，而不是12
int a2 = *p;	// a2 == 155
```

指针 p 所指的对象是 a，a 中现在存储的值是155，因此，把 `*p` 赋给 a2 等价于给 a2 赋值 155。





> **拓展：**
> `引用` 和 `指针` 的区别？



> 聊聊 “左值” 和 “右值”





### ★Q：“const” 关键字大杂烩

#### 1、const关键字（顶层const和底层const）



#### 2、define 和const的区别（编译阶段、安全性、内存占用等）



#### 3、const和static的用法（定义，用途）



#### 4、const和static在类中使用的注意事项（定义、初始化和使用） 



#### 5、const类成员函数（用法和意义），以及和非const成员函数的区别 



### Q：struct和class的区别（分别在C、C++中）



### Q：结构体内存对齐方式和为什么要进行内存对齐？



### Q：final和override关键字



### Q：extern "C"的用法



### Q：“void*” 为何物

> 资料参考：
>
> 1. 《TC++PL》：P128、P149
> 2. cppreference：https://zh.cppreference.com/w/cpp/language/types#void_.E7.B1.BB.E5.9E.8B

#### why：为什么会有 void*

在某些偏向底层的代码中，我们偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址来存储或传递对象。它们的作用大多是操作硬件资源。

例如：

```cpp
void* my_alloc(size_t n);	// 从特定的堆上分配n个字节的内存空间
```

#### what：void* 是什么

void* 的含义是 “指向未知类型对象的指针”。

一个 void* 可以被赋给另一个 void* ，两个 void* 还能比较是否相等，并且我们可以把 void* 显式转换为其他类型。

#### How：怎么用 void*

因为编译器并不清楚 void* 所指的对象到底是什么类型，所以对它执行其他操作并不安全，并且会引发编译错误。

所以，**要使用 void* ，我们必须把它显式转换成某一特定类型的指针。**

例如：

```cpp
void func(int* p) {
    void* p1 = p;	// ok: 发生了从 int* 到 void* 的隐式转换
    *p1 = 1;	// error: 不允许解引用 void*
    ++p1;		// error: 不允许对 void* 执行递增操作（不清楚void* 所指向对象的尺寸）
    
    int* p2 = static_cast<int*>(p1);	// 显示转换回 int*
    
    double* d_p1 = p1;	// error: 要显示转换
    double* d_p2 = p;		// error
    double* d_p3 = static_cast<double*>(p1);	// 不安全
}
```

解释一下 `double* d_p3 = static_cast<double*>(p1);` 为什么不安全？

一般情况下，如果某个指针已经被 强制类型转换 成一种与实际所指对象类型完全不同的新类型，则使用转换后的指针是不安全的行为。

如上面的例子，实际上 p1 所指的是 int 类型的一段内存，假设系统分配的内存占4个字节，而转换后的 double 类型占8个字节，那么操作之后将会造成意想不到的后果。

> warning：**函数指针和指向类成员的指针不能被赋给 void\* 。** 

#### where：void* 主要的用途

1. 当我们无法假定对象的类型时，向函数传递指向该对象的指针；
2. 从函数返回未知类型的对象。（要使用这样的对象，必须先显示类型转换）

> 在系统上层代码中很少用到 void* ，一旦出现，你就要认真核实是不是存在设计上的错误。

例如：

```cpp
void* p;	// 指针所指的对象类型未知
// （PS：待补充）
```



#### 加餐：浅谈 “void”

从语法结构上来讲，void 属于基本类型，但它又是无法变为完整的 **不完整类型** （从而不允许存在 void 类型的对象）

例如：

```cpp
void x;		// error: 不存在 void 类型的对象
void& r;	// error: 不存在到 void 的引用
void func();	// 函数 func 不返回任何实际的值
void* p;	// 指针所指的对象类型未知
```

当我们声明一个函数时，必须指明其返回类型。从逻辑上讲，如果某个函数不返回任何值，也许我们会希望直接忽略返回值部分。但这种想法会违反C++的语法规则。因此，我们使用 void 表示函数的返回值为空，此时 void 可以看成一种 “伪返回类型”。

这样，我们就引出了 void 的用途：

1. 作为函数的返回类型用于说明函数不返回任何实际的值；
2. 作为指针的基本类型部分，以表明指针所指对象的类型未知。



### Q：函数指针 和 指针函数，到底如何区分？



### Q：区分四种强制类型转换 “static_cast、dynamic_cast、const_cast 和 reinterpret_cast”



### Q：decltype()和auto 



### Q：new和delete是如何实现的，new 与 malloc的异同处



### Q：inline和宏定义的区别



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：C++的异常处理 



### Q：C和C++的区别以及类型安全



### Q：C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）



### Q：



## 二、抽象机制

### Q：介绍面向对象的三大特性，并且举例说明每一个



### Q：C++中类的数据成员和成员函数内存分布情况



### Q：C++多态的实现



### Q：public，protected和private访问权限和继承



### Q：this指针



### Q：拷贝初始化和直接初始化，初始化和赋值的区别



### Q：成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？



### Q：介绍C++所有的构造函数



### Q：构造函数声明为explicit 



### Q：构造函数的几种关键字(default delete 0) 



### Q：什么情况下会调用拷贝构造函数（三种情况）



### Q：对象复用的了解，零拷贝的了解 



### Q：深拷贝和浅拷贝的区别（举例说明深拷贝的安全性） 



### Q：构造函数、拷贝构造函数和赋值操作符的区别



### Q：C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）



### Q：纯虚函数



### Q：构造函数或者析构函数中调用虚函数会怎样



### Q：构造函数为什么一般不定义为虚函数 



### Q：析构函数一般写成虚函数的原因 



### Q： 静态类型和动态类型，静态绑定和动态绑定的介绍 



### Q：引用是否能实现动态绑定，为什么引用可以实现 



### Q：



### Q：



### Q：



### Q：



### Q：C++中的重载和重写的区别



### Q：模板函数和模板类的特例化



### Q：模板的用法与适用场景 



## 三、容器和算法



### Q：STL中vector的实现



### Q：vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因？



### Q：STL源码中的hashtable的实现



### Q：STL中unordered_map和map的区别和应用场景



### Q：



### Q：



### Q：STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）



### Q：



### Q：STL中的traits技法



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



### Q：



## 四、并发与实用功能

### Q：C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解



### Q：内存泄露的定义，如何检测与避免？



### Q：volatile关键字 



### Q：



### Q：



### Q：



### Q：智能指针的循环引用



### Q：手写智能指针的实现（shared_ptr和weak_ptr实现的区别）



### Q：内存检查工具的了解



### Q：



### Q：



### Q：



### Q：



## 五、拓展基础知识

### Q：main函数调用前OS做了什么

初始化堆栈指针；全局变量对象及静态变量对象的空间分配和初始化；



### Q：main函数调用后OS做了什么

全局变量析构 对象析构 堆销毁 关闭I/O 关闭标准输入 输出 错误流 调用析构函数



### Q：优化程序的几种方法



### Q：C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）



### Q：C++的调用惯例（简单一点C++函数调用的压栈过程）



### Q：



### Q：遇到coredump要怎么调试



### Q：



### Q：

### Q：

### Q：

### Q：

### Q：

