**前言：**

以下相关知识点主要参考秀哥（拓跋阿秀）的InterviewGuide文档，同时在牛客、网上查找相关资料所整理，十分感谢前辈们的辛勤付出，如果存在侵权请一定联系我进行删除。

这篇文章将目前遇到的常见面试问题进行了一个汇总。

十分感谢各位前辈们！！！在此致敬！

[TOC]

# 计算机网络常考面试题

## 一、HTTP

关于HTTP的详细内容可以去看看《图解HTTP》



### 01、一次完整的HTTP请求过程

- 建立客户端与服务器之间的连接（域名解析 --> TCP三次握手 ）
- 建立连接之后，客户端给服务端发送一个请求（--> 连接建立后发起HTTP请求）
- 服务端收到请求后给予响应信息（--> 服务器响应HTTP请求--> 浏览器得到html代码）
- 客户端浏览器将返回的内容解析并呈现出来（--> 浏览器解析html代码，并请求html代码中的资源(js,css,图片等) --> 浏览器对页面进行渲染呈现给用户）
- 断开连接（--> TCP四次挥手）





### 02、HTTP的特点

1. 灵活：HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。 
2. 无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，不会造成不必要连接占用，缺点在于如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 
3. 支持客户端/服务器模式。 
4. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。





### 03、HTTP的缺点

1. 使用明文进行通信，内容可能会被窃听；
2. 不验证通信方的身份，通信方的身份有可能遭遇伪装；
3. 无法证明报文的完整性，报文有可能遭篡改。





### 04、HTTP1.0和HTTP1.1的区别

**长连接**：HTTP1.0默认使用短连接，每次请求都需要建立新的TCP连接，连接不能复用。HTTP1.1支持长连接，复用TCP连接。

**缓存处理**：在HTTP1.0中主要使用header里的`If-Modified-Since,Expires`来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。

**带宽优化及网络连接的使用**：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

**错误通知的管理**：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**Host头处理**：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。





### 05、HTTP1.1和 HTTP2.0的区别

HTTP2.0相比HTTP1.1支持的特性：

- **新的二进制格式**：HTTP1.1的解析是基于文本。HTTP2.0的协议解析采用二进制格式，实现方便且健壮。
- **多路复用**：一个request对应一个id，这样一个连接上可以有多个request，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **头部压缩**，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小。
- **服务端推送**：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，无需客户端请求。





### 06、HTTP长连接和短连接区别

在HTTP/1.0中默认使用短连接。即客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束中断连接。
例如：如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议会在响应头加入这行代码： `Connextion:keep-alive`
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这条已经建立的连接。这就节省了TCP连接建立和断开的消耗。
`keep-alive` 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。





### 07、什么时候用长连接，短连接

**长连接** 多用于操作频繁，点对点的通讯（微信等聊天系统），而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接再操作的话，那么处理速度会降低很多，所以每个操作完后暂时不断开连接，次处理时直接发送数据包就OK了，不用再建立TCP连接。
例如：数据库的连接用长连接，如果用短连接，频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。

像web网站的HTTP服务一般采用**短连接**，因为长连接对于服务端来说会耗费一定的资源，而像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下用**短连接**更好。





### 08、如何理解HTTP协议是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。





### 09、HTTP请求方法有哪些？

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段：

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP/1.0定义了三种请求方法：GET、POST和HEAD方法
HTTP/1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT方法

![image-20210921113657447](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210921113657447.png)





### 10、HTTP请求报文的格式

HTTP请求由请求行、请求头部、空行和请求体四个部分组成。

- 请求行：请求方法，访问的资源URL，使用的HTTP版本；GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 
- 请求头包含一些属性，格式为“属性名:属性值”，服务端据此获取客户端的信息，主要有cookie、host、connection、accept-language、accept-encoding、user-agent。 
- 请求体：用户的请求数据如用户名，密码等。 

```html
POST /xxx HTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=dabin 请求体
```





### 11、HTTP响应报文的格式

HTTP响应也由四个部分组成，分别是：状态行、响应头、空行和响应体。

- 状态行：协议版本，状态码及状态描述。 
- 响应头：connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires。 
- 响应体：服务器返回给客户端的内容。 

```html
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>
    <body>响应体</body>
</html>
```





### 12、GET和POST的区别

[彻底弄清POST和GET请求的区别，这次你GET了么](https://segmentfault.com/a/1190000023940344)

1. GET是获取数据，POST是修改数据
2. GET请求参数通过URL传递，以 `?`分隔URL和传输数据，参数之间以&相连，所以get不太安全。
   POST的参数放在请求体中
3. get提交的数据最大是2k（限制实际上取决于浏览器），post理论上没有限制
4. GET产生一个TCP数据包，浏览器会把HTTP header 和 data一并发送出去，服务器响应200（返回数据）；
   POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置
6. GET请求只能进行url编码，而POST支持多种编码方式。
7. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

正是因为它们有这样的区别，所以不应该且 **不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的， **在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。

GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上没有区别，只是报文格式不同。





[参考](https://blog.csdn.net/wangmx1993328/article/details/88413696)

### 13、GET方法参数写法是固定的吗？

在约定中，参数是写在？后面，用 & 分割。但也不是绝对的。

解析报文地过程中是通过获取TCP数据，用正则等工具从数据中获取Header 和Body，从而提取参数。
比如header请求头中添加token 来验证用户是否登录等权限问题
也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行。





### 14、POST方法比GET方法安全？

1. 相对来说POST比GET安全一些，因为POST数据在地址栏上不可见，但是从传输角度来说，它们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。
2. 要想安全传输，就只有加密，使用HTTPS





### 15、GET方法的长度限制是怎么回事？

网络上都会提到浏览器地址栏输入的参数是有限的。

但是HTTP协议没有Body和URL的长度限制，对URL限制的大多是浏览器和服务器的原因。

比如服务器因为处理长URL要消耗比较多的资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。浏览器也是为了性能和安全考虑，所以对URL长度有所限制。





### 16、POST方法会产生两个TCP数据包？

HTTP协议中没有明确说明POST会产生两个TCP数据包，而且实际测试（Chrome）发现，header和body不会分开发送。

所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于post必然行为。





### 17、HTTP协议与 TCP/IP协议的关系

HTTP的长连接和短连接本质上TCP的长连接和短连接。

HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。

IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上进行可靠的传递数据包，使在网络上的另一端收到发送端发出的所有报，并且顺序与发出顺序一致。





### 18、一个TCP连接可以对应几个HTTP请求？

如果维持连接，一个TCP连接可以发送多个HTTP请求





### 19、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

HTTP/1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求，即两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠。

虽然HTTP/1.1规范中规定了 **Pipelining** 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

**Pipelining**在实践中会出现许多问题：

- 一些代理服务器不能正确的处理 HTTP Pipelining
- Head-of-line Blocking 连接头阻塞：在建立起一个TCP连接之后，假设客户端在这个连接连续向服务器发送了多个请求。如果按照标准的话，服务器应该按照收到请求的顺序返回结果，假设服务器在处理 首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应，造成了阻塞。

基于Pipelining 的两个问题，现代浏览器默认不开启HTTP Pipelining。

**HTTP2提供了 Multiplexing 多路传输特性，可以在一个TCP连接中同时完成多个HTTP请求！**

![image-20210921115517962](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210921115517962.png)

总结：

在HTTP/1.1存在Pipelining技术可以完成这个多个请求同时发送，但由于**浏览器默认关闭**，所以可以认为这是 **不可行** 的。

在HTTP2中由于 **Multiplexing**特点的存在，多个HTTP请求可以在同一个TCP连接中 **并行**进行。

那么在HTTP/1.1时代，浏览器时如何提高页面加载效率的呢？主要有两点：

1. 维持和服务器已经建立的TCP连接，在同一连接上顺序处理多个请求。
2. 和服务器建立多个TCP连接





### 20、为什么有的时候刷新页面不需要重新建立SSL连接？

TCP连接有的时候会被浏览器和服务端维持一段时间。TCP不需要重新建立，SSL自然也会用之间的。





### 21、浏览器对同一Host建立TCP连接的数量有没有限制？

有。Chrome最多允许对同一个Host建立 6 个TCP连接，不同的浏览器有所区别。





### 22、若收到的HTML包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

如果图片都是 **HTTPS连接并且在同一个域名下**，那么浏览器在SSL握手之后会和服务器商量能不能用 **HTTP2**，如果能的话就使用 Multiplexing功能在这个连接上进行 **多路传输**。不过也未必会所有挂在这个域名的资源都使用一个TCP连接去获取，但是可以确定的是 MUltiplexing很可能会被用到。

如果发现用不了HTTP2，或者用不了HTTPS（现实中的HTTP2都是在HTTPS上实现的，所以也就是只能使用HTTP/1.1）。那么浏览器就会在**一个HOST上建立多个TCP连接** ，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，若所有的连接都正在发送请求，那么其他的请求就只能等待。





### 23、HTTPS是什么?

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。





### 24、HTTP和HTTPS的区别

1. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
2. HTTP 明文传输，数据都是未加密的，安全性较差；HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
3. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
4. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
5. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。





### 25、HTTP中缓存的私有和共有字段

私有缓存即单个用户专享的缓存，比如Web浏览器中的缓存就属于私有缓存。

公有缓存为多个用户共享的缓存，比如共享代理服务器就属于公有缓存，这些服务器又被称为`代理缓存`。

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

```cpp
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中

```cpp
Cache-Control: public
```




### 26、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）

[参考](https://www.cnblogs.com/ranyonsue/p/8918908.html)

max-age指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

```cpp
Cache-Control: max-age=31536000  //（31536000 / 24 / 60 * 60）
```

Expires首部字段也可以用于告知缓存服务器 该资源什么时候会过期。

```cpp
Expires: Thu,31 Dec 2037 23:59:59 GMT
```

- 在 HTTP/1.1 中，会优先处理 max-age 指令；
- 在 HTTP/1.0 中，max-age 指令会被忽略掉。





### 27、HTTP如何禁用缓存？如何确认缓存？

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**禁止进行缓存**
no-store 指令规定不能对请求或响应的任何一部分进行缓存。

```cpp
Cache-Control: no-store
```

**强制确认缓存**
no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

```cpp
Cache-Control: no-cache
```





### 28、常见的HTTP状态码

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：

| 分类 | 分类描述         | 原因短句                               |
| :--- | :--------------- | -------------------------------------- |
| 1**  | 信息性状态码     | 服务器收到请求，需要请求者继续执行操作 |
| 2**  | 成功状态码       | 操作被成功接收并处理                   |
| 3**  | 重定向状态码     | 需要进一步的操作以完成请求             |
| 4**  | 客户端错误状态码 | 请求包含语法错误或无法完成请求         |
| 5**  | 服务器错误状态码 | 服务器在处理请求的过程中发生了错误     |





### 29、HTTP状态码列表

| 状态码  | 状态码英文名称                  | 中文描述                                                     |
| :------ | :------------------------------ | :----------------------------------------------------------- |
| ==100== | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| 101     | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|         |                                 |                                                              |
| ==200== | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201     | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202     | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203     | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| ==204== | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205     | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| ==206== | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|         |                                 |                                                              |
| 300     | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| ==301== | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| ==302== | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| ==303== | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| ==304== | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305     | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306     | Unused                          | 已经被废弃的HTTP状态码                                       |
| ==307== | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|         |                                 |                                                              |
| ==400== | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| ==401== | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402     | Payment Required                | 保留，将来使用                                               |
| ==403== | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| ==404== | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405     | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406     | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407     | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408     | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409     | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410     | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411     | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412     | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413     | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414     | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415     | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416     | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417     | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|         |                                 |                                                              |
| ==500== | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501     | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502     | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| ==503== | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504     | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505     | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |





### 30、在浏览器中输入URL地址后显示主页的过程？

1. 解析域名，找到主机IP。 
2. 浏览器利用IP直接与网站主机通信，三次握手，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 80 端口发起 tcp 的连接。 
3. 建立TCP连接后，浏览器向主机发起一个HTTP请求。 
4. 服务器响应请求，发回网页内容。 
5. 浏览器解析网页内容，进行渲染，呈现给用户。





### 31、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

[小林coding的回答](https://www.zhihu.com/question/34873227/answer/1657140394)

[peanutYu96的回答](https://juejin.cn/post/6844903934872518670)

1. 浏览器查询域名是否在缓存中
2. 如果缓存中没有，调用API（Linux下socket函数gethostbyname）进行查询
3. 如果gethostbyname没有这个域名的缓存记录，也没有在host里找到，它将会向DNS服务器发送一条DNS查询请求，查询本地域名服务器（基于UDP的协议）
4. 如果在一个子网内，采用ARP地址解析协议进行ARP查询；
   如果不在一个子网那就需要对默认网关进行DNS查询；
   如果还找不到会一直向上找根域名服务器，直到最终拿到IP地址
5. 这时候我们就有了服务器的IP地址以及默认的端口号（HTTP默认端口80，HTTPS默认端口443），首先尝试HTTP，然后调用socket建立TCP连接。
6. 经过三次握手成功建立连接后开始传送数据，如果正是HTTP协议的话，返回就完事了。
7. 如果不是HTTP协议，浏览器会返回一个5开头的重定向消息，告诉我们用的是HTTPS，也就是说，IP没变，端口号从80变成443。到这里会进行一次四次挥手。
8. 然后以端口443再次建立连接，同时还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换（三次握手时会沟通好双方使用的认证算法，加密和检验算法，在此过程也会检验对方的CA安全证书）
9. 确认无误后开始通信，服务器会返回你所要访问的网址的一些数据，在此过程中将界面进行渲染，涉及到ajax技术等，直到我们看到色彩斑斓的网页





## 二、DNS

### 01、什么是DNS

DNS是互联网中使用的命名系统，作为 **域名和IP地址相互映射的一个分布式数据库** ，用来便于把人们使用的主机名转换为IP地址。

通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析。

为什么会有DNS呢？

通俗的来讲，我们更习惯记住一个网站的名字如www.csdn.net，而不是他的IP地址 39.106.226.142





### 02、DNS工作原理是什么

首先，主机向本地域名服务器的查询一般采用递归查询；本地域名服务器向根域名服务器的查询通常是采用迭代查询。

具体过程：

1. 浏览器搜索自己的DNS缓存 
2. 若没有，则搜索操作系统中的DNS缓存和hosts文件 
3. 若没有，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的DNS缓存，查找成功则返回结果（递归查询），
   否则依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器（迭代查询） 
4. 本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来 
5. 操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来 
6. 浏览器得到域名对应的IP地址

![image-20210921085358977](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210921085358977.png)





### 03、为什么机器在处理IP数据报时要用IP地址而不使用域名呢？

IPv4中，IP地址的长度是固定的32位（IPv6地址，128位），而域名的长度并不是固定的，机器处理起来比较困难。





### 04、域名解析用什么协议，为什么？

DNS属于应用层协议，使用UDP传输。

因为UDP更快！UDP的DNS协议只需要一个请求一个应答。而基于TCP的DNS协议需要三次握手、发送数据、应答、四次挥手。

注意UDP协议传输的内容不能超过512字节，当然客户端向DNS服务器查询域名，一般返回的内容都不超过512字节





### 05、为什么区域传送用TCP协议？

DNS区域传送**（DNS zone transfer）**指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。

因为TCP协议的可靠性好；另外TCP协议传输的内容大，用最大只能传512字节的UDP协议？外衣同步的数据大于512字节呢。





### 06、DNS负载均衡是什么策略

当一个网站有足够多的用户时，假如每次请求的资源都位于同一台机器上，那么这台机器随时可能会崩掉。
而处理的办法就是利用DNS负载均衡技术，它的原理是：在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。

例如可以根据每台机器的负载量 / 该机器离用户地理位置的距离等等





### 07、为什么服务器会有缓存这项功能？如何实现的？

原因：

- 服务器压力过大，缓解服务器压力
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也可能比源服务器来的近，如浏览器缓存（更快地加载页面，提升用户体验）
- 减少冗余地数据传输，节省带宽

实现方法：

- 让[代理服务器](https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8)进行缓存
- 让客户端浏览器进行缓存





## 三、Cookie & Session

[纯洁的微信](https://www.cnblogs.com/ityouknow/p/10856177.html)

### 01、Cookie是什么？

HTTP协议是无状态的，为了让HTTP协议尽可能简单，使它能处理大量事务，HTTP/1.1引入了Cookie来保存状态信息。

Cookie是服务器发送到用户浏览器并保存在本地的一块小数据，它会在浏览器之后向同一服务器再次发起请求时被携带上。通常，它用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会携带Cookie数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie曾一度用于客户端数据的存储，因为当时并没有其他合适的存储方法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie逐渐被淘汰。

新的浏览器API已经允许开发者直接将数据存储到本地，如使用Web storage API（本地存储和会话存储）或 IndexedDB。

==Cookie的出现是因为HTTP是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie的作用就好比服务器给你贴一个标签，然后你每次向服务器再发请求时，服务器就能够通过Cookie认出你。==

一个Cookie可以认为是一个 [变量]，形如 name = value，存储在浏览器；
一个Session可以理解为一种数据结构，多数情况是[映射]（键值对），存储在服务器





### 02、Cookie的用途

Cookie 主要用于以下三个方面：

1. 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）





### 03、什么是Session？

除了可以将用户信息通过Cookie存储在用户浏览器中，也可以利用Session存储在服务器端，存储在服务器端的信息更加安全。

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

Session可以存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型数据库中，效率会更高。





### 04、使用Session的过程

使用Session维护用户登录状态的过程：

1. 用户进行登录时，用户提交包含用户名和密码的表单放入HTTP请求报文中
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，它在Redis中的Key称为Session ID
3. 服务器返回的响应报文的set-Cookie首部字段包含了这个Session ID，客户端收到响应报文后将该Cookie值存入浏览器中
4. 客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID，从Redis中取出用户信息，继续之前的业务操作。

> 注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。





### 05、Session工作原理

Session在客户端登录完成之后，服务器会创建对应的Session，Session创建完之后，会把Session的ID发送给客户端，客户端会存储到浏览器中。当客户端每次访问服务器时，都会带着Session ID，服务器拿到Session ID之后，在内存中找到与之对应的Session这样就可以正常工作了。





### 06、Cookie和Session对比

HTTP协议作为无状态协议，必然需要以某种方式保持连接状态。

- **Cookie**

  Cookie是客户端保持状态的方法

  Cookie简单的理解就是存储由服务器发送至客户端保存的一段字符。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求该服务器时带上Cookie就可以被识别

  除了以上提到的，Cookie在客户端的保存形式可以有两种，一种是会话Cookie，一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保存在内存中，关闭浏览器后自动销毁；持久Cookie则是存储在客户端磁盘中，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。

- **Session**

  Session是服务器保持状态的方法

  Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户都有独立的Session用户在客户端上记录用户的操作。可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。

当服务器需要识别客户端时就需要结合Cookie。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。

如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如`sid=xxxxx`这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。





### 07、Cookie和Session的区别

Cookie和Session都是客户端与服务器之间保持状态的解决方案

1. 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
2. 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
3. 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
4. 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
5. 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。





### 08、为什么需要 Cookie 和 Session，他们有什么关联？

为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。

那么 Cookie 和 Session 是如何配合的呢？

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 Session ID 返回给浏览器，浏览器接收到服务器返回的 Session ID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 Session ID 属于哪个域名。

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。





### 09、服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转？

第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 `xxx?SessionID=123456...`。

第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。

Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。

当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。





### 10、如何考虑分布式 Session 问题？

在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

- Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
- Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- 共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。

建议采用第三种方案。





### 11、Session和Cookie的使用场景

- Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session
- Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存入Cookie中，可以将Cookie值进行加密，然后在服务器进行解密
- 对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到Session中。





## 四、安全 & 加密

### 01、什么是对称加密和非对称加密？

对称加密：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。

非对称加密：它需要生成两个密钥：公钥和私钥。公钥是公开的，任何人都可以获得，而私钥是私人保管的。我们提交代码到github的时候，就可以***H key：在本地生成私钥和公钥，私钥放在本地`.ssh`目录中，公钥放在github网站上，这样每次提交代码，就不用输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。





### 02、HTTPS采用的加密方式有哪些？是对称还是非对称？

HTTPS 采用混合的加密机制，**使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，**之后使用对称密钥加密进行通信来保证通信过程的效率。**

确保传输安全过程（其实就是rsa原理）：

1. Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2. Server 确认双方使用的加密方法， 并给出数字证书、以及一个服务器生成的随机数（ Serverrandom）。
3. Client确认数字证书有效，然后生成呀一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。
4. Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。
5. Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。





### 03、对称密钥加密的优点缺点？

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快
- 缺点：无法安全地将密钥传输给通信方





### 04、什么是非对称密钥加密，优缺点？

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。





### 05、什么是SSL/TLS？

SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输资料时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。
SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和web服务器之间发送的数据的协议。身份验证，加密HTTPS的加密机制是一种共享密钥加密和公平密钥加密并用的混合加密机制。

TLS（传输层安全）是更为安全的升级版SSL。由于SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作SSL。

SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都是用的是同一个密钥

对称加密：优点在于加密、解密效率通常比较高，HTTPS基于非对称加密，公钥是公开的





### 06、SSL/TLS协议运行机制

[阮一峰](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)





### 07、HTTPS是如何保证数据传输的安全，整体流程是什么？（SSL是怎么工作保证安全的）

[参考](https://blog.51cto.com/u_15162069/2902685)
![image-20210923100645853](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210923100645853.png)

1. 客户端向服务器端发起SSL连接请求
2. 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥
3. 客户端用公钥对双方通信的对称密钥进行加密，并发送给服务端
4. 服务器利用自己唯一的私钥对客户端发来的对称密钥进行解密
5. 然后进行数据传输，服务器和客户端双方用共有的相同的对称密钥对数据进行加密解密，可以保证在数据收发过程中的安全，即使第三方获得数据包也无法对其进行加密、解密和篡改

因为数字签名、摘要是证书防伪非常关键的武器。“摘要” 就是对传输的内容，通过hash算法计算出一段固定长度的串。然后通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。





### 08、SSL中的认证中的证书是什么？

通过使用 证书 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。





### 09、XSS攻击是什么

跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击

1）前端，服务端，同时需要字符串输入的长度限制。
2）前端，服务端，同时需要对HTML转义处理。将其中的”<”,”>”等特殊字符进行转义编码。

防 XSS 的核心是必须对输入的数据做过滤处理。





### 10、CSRF攻击是什么

跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。





### 11、DDos攻击了解吗？

客户端向服务端先发送请求链接数据包，然后服务端向客户端发送确认数据包，但是客户端不向服务端发送确认数据包，最后服务器一直等待来自客户端的确认。

对于DDos攻击没有彻底根治的办法，除非不使用TCP

DDos预防：

1. 限制同时打开SYN半链接的数目
2. 缩短SYN半链接的Time out时间
3. 关闭不必要的服务





### 11、如何防范CSRF攻击

- 安全框架，例如Spring Security。
- token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。
- 验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。
- referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。
  - 1）验证请求来源地址；
  - 2）关键操作添加验证码；
  - 3）在请求地址添加 token 并验证。





### 12、讲一讲文件上传漏洞

文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。

许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。





### 13、如何防范文件上传漏洞

文件上传的目录设置为不可执行。

1. 判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。
2. 对上传的文件类型进行白名单校验，只允许上传可靠类型。
3. 上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。
4. 限制上传文件的大小。
5. 单独设置文件服务器的域名。





## 五、TCP & UDP

### 01、TCP是什么？

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。





### 02、UDP是什么？

UDP提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。





### 03、TCP的特点是什么

- TCP是面向连接的运输层协议
- 点对点，每一条TCP连接只能有两个端点
- TCP提供可靠交付的服务.
  通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
- TCP提供全双工通信。
  TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据
- 面向字节流。
  TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。





### 04、UDP的特点是什么

- UDP是无连接的；
- UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
- UDP是面向报文的；
- UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；
- UDP支持一对一、一对多、多对一和多对多的交互通信；
- UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。





### 05、TCP和UDP的区别？

1. TCP面向连接（如打电话要先拨号建立连接）
   UDP是无连接的，即发送数据之前不需要建立连接 
2. TCP提供可靠的服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达
   UDP尽最大努力交付，即不保证可靠交付
3. TCP面向字节流，把数据看成一连串无结构的字节流
   UDP是面向报文的 
4. TCP有拥塞控制；
   UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 
5. 每一条TCP连接只能是点到点的；
   UDP支持一对一，一对多，多对一和多对多的交互通信 
6. TCP首部开销20字节；UDP的首部开销小，只有8个字节
7. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道





### 06、TCP 和 UDP 对应的应用场景是什么？

TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP文件传输 
- HTTP / HTTPS 

UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP等 
- 视频、音频等多媒体通信 
- 广播通信





### 07、TCP 和 UDP 分别对应的常见应用层协议

**TCP**

- FTP：定义了文件传输协议，使用21端口.
- Telnet：它是一种用于远程登陆的端口,23端口
- SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。
- POP3：它是和SMTP对应，POP3用于接收邮件。

**UDP**

- DNS：用于域名解析服务，用的是53号端口
- SNMP：简单网络管理协议，使用161号端口
- TFTP：简单文件传输协议，69号端口





### 08、TCP头部中有哪些信息？

- 序号（32 bit）：传输方向上字节流的字节序号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时， **序号值 = ISN + 数据在整个字节流中的偏移**。假设 A->B 且 ISN = 1024，第一段数据512字节已经到了B，则第二段数据发送时序号为1024 + 512.用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
- 首部长（4bit）：标识首部有多少个4字节 \* 首部长，最大为15，即60字节。
- 标志位（6bit）：
  - URG：标志紧急指针是否有效
  - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - PSH：提示接收端立即从缓冲读走数据。
  - SYN：表示请求建立一个连接（连接报文段）。
  - FIN：表示关闭连接（断开报文段）。
- 窗口（16bit）：接受窗口。用于告知对方（发送方）本方的缓冲还能接受多少字节数据。用于解决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。





### 09、常见的TCP的连接状态有哪些？

- CLOSED：初始状态
- LISTEN：服务器处于监听状态
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
- FIN_WAIT_1：终止连接的一方（通常是客户端）发送了FIN报文后进入。等待对方FIN
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，将纳入此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。





### 10、TCP头部报文字段有哪些，以及各自的功能

![image-20210923171158858](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210923171158858.png)

![image-20210923171220824](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210923171220824.png)





### 11、TCP的三次握手详细过程

[小林coding](https://www.cnblogs.com/xiaolincoding/p/12638546.html)

[大白话理解三握四挥](https://github.com/jawil/blog/issues/14)

![image-20210923182022242](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210923182022242.png)

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

**三次握手的过程**

- 初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。
- 第一次握手：客户端发送请求报文将 SYN = 1同步序列号和初始化序列号seq = x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）
- 第二次握手：服务端受到 SYN 请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) = 1、初始化序列号 seq = y和确认序列号（期望下次收到的数据包）ack = x+ 1 以及确认号ACK = 1报文作为应答，服务器为SYN_Receive状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
- 第三次握手： 客户端接收到服务端的 SYN + ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 ack = y + 1和数据包的序列号 seq = x + 1以及确认号ACK = 1确认包作为应答，客户端转为established状态。（分别站在双方的角度上思考，各自ok）

在socket编程中，客户端执行connect()时，将触发三次握手。





### 12、TCP的四次挥手详细过程

![image-20210923182034406](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210923182034406.png)

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

**四次挥手过程**

- 初始化状态：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。

- 第一次挥手：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。

  > 假如客户端发送的数据已经发送完毕，发送FIN = 1 告诉服务端，客户端所有数据已经全发完了，服务端你可以关闭接收了，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。

- 第二次挥手：服务端接收到客户端的释放请求连接之后，知道客户端没有数据要发给自己了，然后服务端发送ACK = 1告诉客户端收到你发给我的信息，此时服务端处于 CLOSE_WAIT 等待关闭状态。
  （服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）

- 第三次挥手：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，用于告诉客户端，服务端的所有数据发送完毕，客户端你也可以关闭接收数据连接了。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。
  （服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）

- 第四次挥手：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。有一个 2 MSL 的延迟等待。





### 13、为什么需要三次握手，两次不行吗？

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

> 如果是用两次握手，则会出现下面这种情况：
>
> 如A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。连接成功，等待数据传输完毕后，就释放了连接。而A发出的第一个连接请求等到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一直等待A发送数据，浪费资源。





### 14、三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来
接收这些报文。

也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。





### 15、为什么连接的时候是三次握手，断开的时候却要挥手需要四次？

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的连接释放报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。





### 16、四次挥手释放连接时，等待2MSL的意义?

> MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

**两个理由**

1. 保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
2. 防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。





### 17、讲一讲FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态

- FIN_WAIT_2：
  - 半关闭状态。
  - 发送断开请求一方还有接收数据能力，但已经没有发送数据能力。
- CLOSE_WAIT状态：
  - 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。
  - 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。
- TIME_WAIT状态：
  - 又叫2MSL等待状态。
  - 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。
  - 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。





### 18、为什么客户端在TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。





### 19、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？

close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：

- 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法
- 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收

处理方法：

- 停止应用程序
- 修改程序里的bug





### 20、什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

再补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......





### 21、ISN(Initial Sequence Number)是固定的吗？

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。





### 22、TCP是如何利用滑动窗口实现流量控制的

流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。

例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。





### 23、是否了解流量控制原理？

目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。

TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。

- 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
- 接收窗：用来标记可以接收的数据大小。

TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收
部分。

发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。





### 24、TCP四大拥塞控制算法总结

拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。

![image-20210925102306437](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210925102306437.png)

#### 慢开始

把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。

- 当 cwnd < ssthresh 时，使用慢开始算法。
- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

#### 拥塞避免

让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

#### 快重传

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。

快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。

发送方只要一连收到**三个重复确认**就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

#### 快恢复

当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。





### 25、为什么快重传是选择3次ACK？

主要的考虑仍是要区分包的丢失是因为链路故障仍是乱序等其余因素引起。

两次duplicated ACK时极可能是乱序形成的！三次duplicated ACK时极可能是丢包形成的！四次duplicated ACK更更更多是丢包形成的，可是这样的响应策略太慢。丢包确定会形成三次duplicated ACK!综上是 选择收到三个重复确认时窗口减半效果最好，这是实践经验。

在没有fast retransmit / recovery 算法以前，重传依靠发送方的retransmit timeout，就是在timeout内若是没 有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失缘由：

1）包checksum 出错事件
2）网络拥塞路由
3）网络断，包括路由重收敛，可是发送方没法判断是哪种状况，因而采用最笨的办法，就是将本身 的发送速率减半，即CWND 减为1/2，这样的方法对2是有效的，能够缓解网络拥塞，3则无所谓，反正 网络断了，不管发快发慢都会被丢；但对于1来讲，丢包是由于偶尔的出错引发，一丢包就对半减速不 合理。

因而有了fast retransmit 算法，基于在反向还能够接收到ACK，能够认为网络并无断，不然也接收不到 ACK，若是在timeout 时间内没有接收到> 2 的duplicated ACK，则几率大事件为乱序，乱序无需重传， 接收方会进行排序工做；

而若是接收到三个或三个以上的duplicated ACK，则大几率是丢包，能够逻辑推理，发送方能够接收 ACK，则网络是通的，多是一、2形成的，先不降速，重传一次，若是接收到正确的ACK，则一切 OK，流速依然（包出错被丢）。

而若是依然接收到duplicated ACK，则认为是网络拥塞形成的，此时降速则比较合理。





### 26、解释一下RTO，RTT和超时重传

- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：
  - 发送的数据没能到达接收端，所以对方没有响应。
  - 接收端接收到数据，但是ACK报文在返回过程中丢失。
  - 接收端拒绝或丢弃数据。
- RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。
  - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......
  - 重传次数到达上限之后停止重传。
- RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。





### 27、TCP 协议如何保证可靠传输？

- 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- 数据校验：TCP报文头有校验和，用于校验报文是否损坏。
- 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
- 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止
  包丢失。
- 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。





### 28、如何区分流量控制和拥塞控制？

- 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。
- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。
- 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。





### 29、什么是TCP粘包/拆包？发生的原因？解决策略？

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是TCP粘包/拆包问题。

原因：

1. 应用程序write写入数据的字节大小 ＞ 套接字发送缓冲区的大小
2. 进行MSS大小的TCP分段（MSS = TCP报文段长度 - TCP首部长度）
3. 以太网的payload ＞ MTU进行IP分片（MTU指一种通信协议的某一层上面所能通过的最大数据包大小）

![image-20210921101451901](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210921101451901.png)

解决策略：

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

1. 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格
2. 在包尾增加回车换行符进行分隔，例如FTP协议
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度。
4. 更复杂的应用层协议，如[RTMP协议](https://mingyangshang.github.io/2016/03/06/RTMP%E5%8D%8F%E8%AE%AE/)等
5. Nagle算法问题导致的，需要结合应用场景适当关闭该算法





### 30、UDP编程中，一次能发送多少个bytes为好？

[术之多](https://www.shuzhiduo.com/A/x9J2yRNjz6/)

当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的,我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:

首先,我们知道,TCP/IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.

下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.

所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。

当我们发送的UDP数据大于1472的时候会怎样呢？
这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便
无法重组数据报.将导致丢弃整个UDP数据报。

因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.

进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.
如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.

鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.
最好将UDP的数据长度控件在548字节(576-8-20)以内





### 31、封包和拆包是基于TCP还是UDP的？

封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。

- 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
- 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。





### 32、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 `Connection: keep-alive`的 Header 进行了支持。也就是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。

持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 `Connection: close`，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 `Connection: close `才会在请求完成后关闭连接。





### 33、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？

端口号上限是65536。因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上
还要少1024个端口号。

而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。





### 34、TCP的有限状态机

![image-20210925111251372](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210925111251372.png)





### 35、建立TCP服务器的各个系统调用过程是怎样的？

![image-20210925104432700](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210925104432700.png)

![image-20210925104443430](https://gitee.com/ClimberCoding/picturebed/raw/master/img/image-20210925104443430.png)

**学习网络编程时再补充**





### 36、SYN攻击是什么？

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击**。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```cpp
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术





## 六、网络层

### 01、Ping命令基于哪一层协议？

ping命令基于网络层的命令，是基于ICMP协议工作的。





### 02、什么是RARP？它的工作原理是什么？

RARP是反向地址转换协议，属于网络层协议，RARP和ARP工作方式相反。RARP使得只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。

原理：

1. 网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。
2. RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。
3. PC收到RARP回应后，就使用得到的IP地址进行通讯。





### 03、网络层常见协议

| 协议 |         名称         |                             作用                             |
| :--: | :------------------: | :----------------------------------------------------------: |
|  IP  |       网际协议       | IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |
| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |
| RIP  |     路由信息协议     |       使用“跳数”(即metric)来衡量到达目标地址的路由距离       |
| IGMP |  Internet组管理协议  |                   用于实现组播、广播等通信                   |
| ARP  |     地址解析协议     |                    根据IP地址获取物理地址                    |
| RARP |   反向地址转换协议   |                    根据物理地址获取IP地址                    |





### 04、讲讲ARP协议

ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。

- 每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。 
- 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。 
- 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 
- 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。 
- 如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。





## 七、其他

### 01、为何需要把TCP/IP协议栈分为5层（7层）？开放式回答

ARPANET的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的

分层的好处：

1. 隔层之间是独立的
2. 灵活性好
3. 结构上可以分隔
4. 易于实现和维护
5. 能促进标准化工作





### 02、OSI七层模型的主要功能

| OSI七层模型 |                             功能                             |                        对应的网络协议                        |
| :---------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   应用层    | 应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为为用户提供常用的应用程序，每个网络应用都对应着不同的协议 |               HTTP、TFTP, FTP, NFS, WAIS、SMTP               |
|   表示层    | 主要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译 |                 Telnet, Rlogin, SNMP, Gopher                 |
|   会话层    | 负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信 |                          SMTP, DNS                           |
|   传输层    | 是整个网络关键的部分，是实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输。 |                           TCP, UDP                           |
|   网络层    |  进行逻辑地址寻址，实现不同网络之间的路径选择，IP就在网络层  |                IP, ICMP, ARP, RARP, AKP, UUCP                |
| 数据链路层  | 物理地址（MAC地址），网络设备的唯一身份标识。建立逻辑连接、进行硬件地址寻址，相邻的两个设备间的互相通信 | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继 |
|   物理层    | 七层模型中的最底层，主要是物理介质传输媒介（网线或者是无线），在不同设备中传输比特，将0/1信号与电信号或者光信号互相转化 |              IEEE 802.1A, IEEE 802.2到IEEE 802               |

![1099668-20170212153338135-125492424](https://gitee.com/ClimberCoding/picturebed/raw/master/img/1099668-20170212153338135-125492424.jpg)





### 03、应用层常见协议

|  协议  |           名称           |    默认端口    |                                                           |
| :----: | :----------------------: | :------------: | :-------------------------------------------------------: |
|  HTTP  |      超文本传输协议      |       80       |                            TCP                            |
| HTTPS  |    超文本传输安全协议    |      443       |                            TCP                            |
|  DNS   |         域名解析         |       53       | **DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。** |
|  FTP   |       文件传输协议       | 20传输和21连接 |                            TCP                            |
|  TFTP  |     简单文本传输协议     |       21       |                            UDP                            |
| Telnet |  远程登录服务的标准协议  |       23       |                            TCP                            |
|  SMTP  | 简单邮件传输协议（发送） |       25       |                            TCP                            |
|  POP   |     邮局协议（接收）     |      110       |                            TCP                            |

DNS区域传输的时候使用TCP协议：

1. 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
2. TCP是一种可靠连接，保证了数据的准确性。

域名解析时使用UDP协议：

客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。





### 04、端口有效范围是多少？

0-1023位知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）

UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0-65535。动态端口的范围是从1024-65535.





### 05、MSS和MTU分别是什么？

- MTU：Maximum Transmission Unit，最大传输单元，由硬件规定，如以太网的MTU位1500字节。
- MSS：Maximum Segment Size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端对端TCP通知对端在每个分节中能发送的最大TCP数据。
  MSS值为MTU值 -减去 IPv4 Header（20 Byte）和 TCP header（20 Byte）得到。





### 06、什么是PPP协议

PPP是点对点协议，主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案

